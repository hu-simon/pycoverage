
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <title>pycoverage.vorutils package &#8212; PyCoverage v0.2 User Manual</title>
    <link rel="stylesheet" href="_static/bootstrap-astropy.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <script type="text/javascript" src="_static/sidebar.js"></script>
    <script type="text/javascript" src="_static/copybutton.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,600' rel='stylesheet' type='text/css'/>

  </head><body>
<div class="topbar">
  <a class="brand" title="Documentation Home" href="index.html"><span id="logotext1">astro</span><span id="logotext2">py</span><span id="logotext3">:docs</span></a>
  <ul>
    
    <li><a class="homelink" title="Astropy Homepage" href="http://www.astropy.org"></a></li>
    <li><a title="General Index" href="genindex.html">Index</a></li>
    <li><a title="Module Index" href="py-modindex.html">Modules</a></li>
    <li>
      
      
<form action="search.html" method="get">
  <input type="text" name="q" placeholder="Search" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
      
    </li>
  </ul>
</div>

<div class="related">
    <h3>Navigation</h3>
    <ul>
      <li>
	<a href="index.html">PyCoverage v0.2 User Manual</a>
	 &#187;
      </li>
      
       
    </ul>
</div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="pycoverage-vorutils-package">
<h1>pycoverage.vorutils package<a class="headerlink" href="#pycoverage-vorutils-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-pycoverage.vorutils.playground">
<span id="pycoverage-vorutils-playground-module"></span><h2>pycoverage.vorutils.playground module<a class="headerlink" href="#module-pycoverage.vorutils.playground" title="Permalink to this headline">¶</a></h2>
<p>Python playground file used for testing algorithm ideas.</p>
<dl class="py function">
<dt id="pycoverage.vorutils.playground.compute_circles">
<code class="sig-prename descclassname">pycoverage.vorutils.playground.</code><code class="sig-name descname">compute_circles</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">points</span></em>, <em class="sig-param"><span class="n">sig_dig</span><span class="o">=</span><span class="default_value">4</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycoverage.vorutils.playground.compute_circles" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the distances from the centroid to the vertices of the convex polygon and returns circles whose radius are the distances.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>points</strong><span class="classifier">numpy.ndarray instance</span></dt><dd><p>Array containing tuples (x, y) representing coordinates in 2-D of the points defining the convex polygon.</p>
</dd>
<dt><strong>sig_dig</strong><span class="classifier">int, optional</span></dt><dd><p>The number of significant digits to truncate the computational results, by default 4 significant digits.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>circles</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Array containing a list of circles defined by the coordinates (x, y, radius) which determine the circles.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># TODO</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="pycoverage.vorutils.playground.compute_enclosing_circle">
<code class="sig-prename descclassname">pycoverage.vorutils.playground.</code><code class="sig-name descname">compute_enclosing_circle</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">points</span></em>, <em class="sig-param"><span class="n">sig_dig</span><span class="o">=</span><span class="default_value">4</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycoverage.vorutils.playground.compute_enclosing_circle" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the smallest enclosing circle that contains the convex polygon.</p>
<p>This is computed by finding the geometric center of the polygon and then finding the largest distance between the centroid and <code class="docutils literal notranslate"><span class="pre">points</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>points</strong><span class="classifier">numpy.ndarray instance</span></dt><dd><p>Array containing tuples (x, y) representing coordinates in 2-D of the points defining the convex polygon.</p>
</dd>
<dt><strong>sig_dig</strong><span class="classifier">int, optional</span></dt><dd><p>The number of siginificant digits to truncate the computational results, by default 4 significant digits.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>circle</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Array containing the coordinates (x, y, radius) that define the minimum enclosing circle.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># TODO</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="pycoverage.vorutils.playground.compute_polygon_area">
<code class="sig-prename descclassname">pycoverage.vorutils.playground.</code><code class="sig-name descname">compute_polygon_area</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">points</span></em>, <em class="sig-param"><span class="n">sig_dig</span><span class="o">=</span><span class="default_value">4</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycoverage.vorutils.playground.compute_polygon_area" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the area of a convex polygon defined by points using a shoelace formula.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>points</strong><span class="classifier">numpy.ndarray instance</span></dt><dd><p>Array containing tuples (x, y) representing coordinates in 2-D of the points defining the convex polygon.</p>
</dd>
<dt><strong>sig_dig</strong><span class="classifier">int, optional</span></dt><dd><p>The number of significant digits to truncate the computational results, by default 4 significant digits.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>area</strong><span class="classifier">float</span></dt><dd><p>Area of the convex polygon, defined by <code class="docutils literal notranslate"><span class="pre">points</span></code>, truncated to <code class="docutils literal notranslate"><span class="pre">sig_dig</span></code> significant digits.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># TODO</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="pycoverage.vorutils.playground.compute_polygon_centroid">
<code class="sig-prename descclassname">pycoverage.vorutils.playground.</code><code class="sig-name descname">compute_polygon_centroid</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">points</span></em>, <em class="sig-param"><span class="n">sig_dig</span><span class="o">=</span><span class="default_value">4</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycoverage.vorutils.playground.compute_polygon_centroid" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the geometric centroid of the convex polygon, defined by <code class="docutils literal notranslate"><span class="pre">points</span></code>, using a shoelace formula.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>points</strong><span class="classifier">numpy.ndarray instance</span></dt><dd><p>Array containing tuples (x, y) representing coordinates in 2-D of the points defining the convex polygon.</p>
</dd>
<dt><strong>sig_dig</strong><span class="classifier">int, optional</span></dt><dd><p>The number of significant digits to truncate the computational results, by default 4 significant digits.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>centroid</strong><span class="classifier">numpy.ndarray instance</span></dt><dd><p>Geometric centroid of the convex polygon, defined by <code class="docutils literal notranslate"><span class="pre">points</span></code>, truncated to <code class="docutils literal notranslate"><span class="pre">sig_dig</span></code> significant digits.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># TODO</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="pycoverage.vorutils.playground.find_meb">
<code class="sig-prename descclassname">pycoverage.vorutils.playground.</code><code class="sig-name descname">find_meb</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">points</span></em>, <em class="sig-param"><span class="n">sig_dig</span><span class="o">=</span><span class="default_value">4</span></em>, <em class="sig-param"><span class="n">epsilon</span><span class="o">=</span><span class="default_value">0.01</span></em>, <em class="sig-param"><span class="n">stop_tol</span><span class="o">=</span><span class="default_value">0.01</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycoverage.vorutils.playground.find_meb" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes an approximation to the minimum enclosing ball that encloses the convex polygon defined by <code class="docutils literal notranslate"><span class="pre">points</span></code>.</p>
<p>The minimum enclosing ball is computed using the Frank-Wolfe algorithm (insert reference here) and iteratively converges to the minimum enclosing ball.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>points</strong><span class="classifier">numpy.ndarray instance</span></dt><dd><p>Array containing tuples (x, y) representing coorddinates in 2-D of the points defining the convex polygon.</p>
</dd>
<dt><strong>sig_dig</strong><span class="classifier">int, optional</span></dt><dd><p>The number of siginificant digits to truncate the computational ressults, by default 4 significant digits.</p>
</dd>
<dt><strong>epsilon</strong><span class="classifier">float, optional</span></dt><dd><p>Parameter determining the acceptable error of the approximation and number of iterations, by default 1e-3.</p>
</dd>
<dt><strong>stop_tol</strong><span class="classifier">float, optional</span></dt><dd><p>Stopping tolerance used for ending iterations early.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>circle</strong><span class="classifier">numpy.ndarray instance</span></dt><dd><p>Array containing the coordinates (x, y, radius) that define the minimum enclosing ball.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Note that the smaller <code class="docutils literal notranslate"><span class="pre">epsilon</span></code> is, the more accurate the result. However, this also increases the number of iterations by a factor of two-fold, so choose this parameter wisely.</p>
<p>The parameter <code class="docutils literal notranslate"><span class="pre">stop_tol</span></code> is used to determine if the algorithm should be terminated early. If the absolute difference between the newly computed center and the previous center is smaller than <code class="docutils literal notranslate"><span class="pre">stop_tol</span></code>, then the algorithm is terminated early.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># TODO</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="pycoverage.vorutils.playground.generate_random_points">
<code class="sig-prename descclassname">pycoverage.vorutils.playground.</code><code class="sig-name descname">generate_random_points</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">poly</span></em>, <em class="sig-param"><span class="n">num_points</span></em>, <em class="sig-param"><span class="n">min_dist</span><span class="o">=</span><span class="default_value">0.0</span></em>, <em class="sig-param"><span class="n">sig_dig</span><span class="o">=</span><span class="default_value">4</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycoverage.vorutils.playground.generate_random_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates random tuples of the form (x, y) which lie in the interior of a convex hull and are separated by <code class="docutils literal notranslate"><span class="pre">min_dist</span></code> distance, using rejection sampling. It is assumed that the hull vertices are ordered in counter-clockwise order.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>poly</strong><span class="classifier">shapely.geometry.Polygon instance</span></dt><dd><p>Convex hull used for determining membership during rejection sampling.</p>
</dd>
<dt><strong>num_points</strong><span class="classifier">int</span></dt><dd><p>Number of points to be generated.</p>
</dd>
<dt><strong>min_dist</strong><span class="classifier">float, optional</span></dt><dd><p>The minimum separation distance enforced for each point, by default 0.</p>
</dd>
<dt><strong>sig_dig</strong><span class="classifier">int, optional</span></dt><dd><p>The number of significant digits to truncate the computational results, by default 4 significant digits.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>random_points</strong><span class="classifier">list</span></dt><dd><p>Unordered list of tuples of the form (x, y) representing the randomly sampled points which lie within the convex hull, and are separated by a distance of <code class="docutils literal notranslate"><span class="pre">min_dist</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function does not compute the packing number, which is needed to determine if it is possible to generate <code class="docutils literal notranslate"><span class="pre">num_points</span></code> points that are separated by a distance of <code class="docutils literal notranslate"><span class="pre">min_dist</span></code> distance. It is the responsibility of the user to ensure that the problem is feasible.</p>
<p>It is assumed that the hull vertices are ordered in counter-clockwise order.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Generates 3 points with ``min_dist`` of 1.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hull</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">Polygon</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">95</span><span class="p">,</span> <span class="mi">31</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">59</span><span class="p">,</span> <span class="o">-</span><span class="mi">81</span><span class="p">],</span> <span class="p">[</span><span class="mi">95</span><span class="p">,</span> <span class="mi">31</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">random_points</span> <span class="o">=</span> <span class="n">geoutils</span><span class="o">.</span><span class="n">generate_random_points</span><span class="p">(</span><span class="n">hull</span><span class="p">,</span> <span class="n">num_points</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">min_dist</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Fail case where the problem is not feasible. The result is an infinite runtime!</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hull</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">Polygon</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">95</span><span class="p">,</span> <span class="mi">31</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">59</span><span class="p">,</span> <span class="o">-</span><span class="mi">81</span><span class="p">],</span> <span class="p">[</span><span class="mi">95</span><span class="p">,</span> <span class="mi">31</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">random_points</span> <span class="o">=</span> <span class="n">geoutils</span><span class="o">.</span><span class="n">generate_random_points</span><span class="p">(</span><span class="n">hull</span><span class="p">,</span> <span class="n">num_points</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">min_dist</span><span class="o">=</span><span class="mf">100.</span><span class="p">)</span>
</pre></div>
</div>
<p>TODO need to fix the examples so that they work with the sig_dig option.</p>
</dd></dl>

<dl class="py function">
<dt id="pycoverage.vorutils.playground.plot_all_circles">
<code class="sig-prename descclassname">pycoverage.vorutils.playground.</code><code class="sig-name descname">plot_all_circles</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">poly</span></em>, <em class="sig-param"><span class="n">circles</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycoverage.vorutils.playground.plot_all_circles" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots the convex polygon and the circles obtained from <code class="docutils literal notranslate"><span class="pre">compute_circles()</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>poly</strong><span class="classifier">shapely.geometry.Polygon</span></dt><dd><p>The convex polygon representing the original operating environment.</p>
</dd>
<dt><strong>circles</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Array containing a list of circles defined by the coordinates (x, y, radius) which determine the circles.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># TODO</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="pycoverage.vorutils.playground.plot_enclosing_circle">
<code class="sig-prename descclassname">pycoverage.vorutils.playground.</code><code class="sig-name descname">plot_enclosing_circle</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">poly</span></em>, <em class="sig-param"><span class="n">circle</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycoverage.vorutils.playground.plot_enclosing_circle" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots the convex polygon and the minimum enclosing circle.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>poly</strong><span class="classifier">shapely.geometry.Polygon instance</span></dt><dd><p>The convex polygon representing the original operating environment.</p>
</dd>
<dt><strong>circle</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Array containing the coordinates (x, y, radius) that define the minimum enclosing circle.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># TODO</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="module-pycoverage.vorutils.pyvoro">
<span id="pycoverage-vorutils-pyvoro-module"></span><h2>pycoverage.vorutils.pyvoro module<a class="headerlink" href="#module-pycoverage.vorutils.pyvoro" title="Permalink to this headline">¶</a></h2>
<p>Python file containing utilities for basic Voronoi operations.</p>
<p>Some other documentation here, explaining more about this module.</p>
<dl class="py function">
<dt id="pycoverage.vorutils.pyvoro.compute_closest_point">
<code class="sig-prename descclassname">pycoverage.vorutils.pyvoro.</code><code class="sig-name descname">compute_closest_point</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">poly</span></em>, <em class="sig-param"><span class="n">points</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycoverage.vorutils.pyvoro.compute_closest_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the closest point that is contained inside the polygon.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>poly</strong><span class="classifier">shapely.geometry.Polygon</span></dt><dd><p>Polygon representing the domain of operation.</p>
</dd>
<dt><strong>points</strong><span class="classifier">list</span></dt><dd><p>List of current agent positions.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>closest_point</strong><span class="classifier">tuple</span></dt><dd><p>(x,y) coordinates of the closest agent.</p>
</dd>
<dt><strong>idx_closest_point</strong><span class="classifier">int</span></dt><dd><p>Index of the closest point contained in the polygon.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>If used properly, under the Voronoi partitions framework, or actually any other framework where we have a proper partition, i.e. disjoint regions with no overlap, with respect to the agent positions, then this returns a unique agent position. Otherwise, no guarantees.</p>
<p>The best way to use this function is essentially to treat the input poly as ONE Voronoi region and find the coordinates of the agent who is assigned this Voronoi region.</p>
<p>It is assumed that the polygon vertices ordered in a counter-clockwise order.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Find coordinates of agent that is assigned to a rectangle.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">polygon</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">Polygon</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">points</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">],</span> <span class="p">[</span><span class="mi">80</span><span class="p">,</span> <span class="mi">80</span><span class="p">],</span> <span class="p">[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">closest_point</span><span class="p">,</span> <span class="n">idx_closest_point</span> <span class="o">=</span> <span class="n">pyvoro</span><span class="o">.</span><span class="n">compute_closest_point</span><span class="p">(</span><span class="n">polygon</span><span class="p">,</span> <span class="n">points</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">closest_point</span><span class="p">)</span>
<span class="go">[5, 5]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">idx_closest_point</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="pycoverage.vorutils.pyvoro.compute_polygon_area">
<code class="sig-prename descclassname">pycoverage.vorutils.pyvoro.</code><code class="sig-name descname">compute_polygon_area</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">points</span></em>, <em class="sig-param"><span class="n">sig_dig</span><span class="o">=</span><span class="default_value">4</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycoverage.vorutils.pyvoro.compute_polygon_area" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the area of a convex polygon defined by points using a shoelace formula.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>points</strong><span class="classifier">numpy.ndarray instance</span></dt><dd><p>Array containing tuples (x, y) representing coordinates in 2-D of the points defining the convex polygon.</p>
</dd>
<dt><strong>sig_dig</strong><span class="classifier">int, optional</span></dt><dd><p>The number of significant digits to truncate the computational results, by default 4 significant digits.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>area</strong><span class="classifier">float</span></dt><dd><p>Area of the convex polygon, defined by <code class="docutils literal notranslate"><span class="pre">points</span></code>, truncated to <code class="docutils literal notranslate"><span class="pre">sig_dig</span></code> significant digits.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># TODO</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="pycoverage.vorutils.pyvoro.compute_polygon_centroid">
<code class="sig-prename descclassname">pycoverage.vorutils.pyvoro.</code><code class="sig-name descname">compute_polygon_centroid</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">points</span></em>, <em class="sig-param"><span class="n">sig_dig</span><span class="o">=</span><span class="default_value">4</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycoverage.vorutils.pyvoro.compute_polygon_centroid" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the geometric centroid of the convex polygon, defined by <code class="docutils literal notranslate"><span class="pre">points</span></code>, using a shoelace formula.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>points</strong><span class="classifier">numpy.ndarray instance</span></dt><dd><p>Array containing tuples (x, y) representing coordinates in 2-D of the points defining the convex polygon.</p>
</dd>
<dt><strong>sig_dig</strong><span class="classifier">int, optional</span></dt><dd><p>The number of significant digits to truncate the computational results, by default 4 significant digits.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>centroid</strong><span class="classifier">numpy.ndarray instance</span></dt><dd><p>Geometric centroid of the convex polygon, defined by <code class="docutils literal notranslate"><span class="pre">points</span></code>, truncated to <code class="docutils literal notranslate"><span class="pre">sig_dig</span></code> significant digits.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># TODO</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="pycoverage.vorutils.pyvoro.create_finite_voronoi_2d">
<code class="sig-prename descclassname">pycoverage.vorutils.pyvoro.</code><code class="sig-name descname">create_finite_voronoi_2d</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">vor</span></em>, <em class="sig-param"><span class="n">radius</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycoverage.vorutils.pyvoro.create_finite_voronoi_2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an infinite Voronoi partition, creates a finite Voronoi partition in 2D by extending the infinite ridges and taking intersections of sets.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vor</strong><span class="classifier">scipy.spatial.Voronoi instance</span></dt><dd><p>Object containing information about the infinite Voronoi partition.</p>
</dd>
<dt><strong>radius</strong><span class="classifier">float, optional</span></dt><dd><p>Float representing the distance to the “point at infinity”, i.e. the point at which all the infinite ridges are extended to. If no radius is specified, we take the farthest point in the partition and multiply it by 100.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>regions</strong><span class="classifier">list</span></dt><dd><p>Indices of the vertices in the new finite Voronoi partition.</p>
</dd>
<dt><strong>vertices</strong><span class="classifier">list</span></dt><dd><p>List of coordinates, in (x,y), of the new finite Voronoi partition. These are the same coordinates returned by scipy.spatial.Voronoi() but the points at infinity are also appended to this list.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This code has been adapated from <a class="reference external" href="https://stackoverflow.com/questions/20515554/colorize-voronoi-diagram/20678647#20678647">https://stackoverflow.com/questions/20515554/colorize-voronoi-diagram/20678647#20678647</a>. Please refer to the thread for more information.</p>
<p>For best results, it is best to leave the radius argument alone. Do not be afraid of the large numbers that end up in the result. This is expected, as we are placing the point at infinity very far away, for a proper partition even in worst case scenarios.</p>
<p>It is assumed that the polygon vertices are ordered in a counter-clockwise order.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Generate a finite 2D Voronoi object.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">polygon</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">Polygon</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">95</span><span class="p">,</span> <span class="mi">31</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">59</span><span class="p">,</span> <span class="o">-</span><span class="mi">81</span><span class="p">],</span> <span class="p">[</span><span class="mi">95</span><span class="p">,</span> <span class="mi">31</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">points</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">50</span><span class="p">,</span> <span class="mi">30</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vor</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">spatial</span><span class="o">.</span><span class="n">Voronoi</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">regions</span><span class="p">,</span> <span class="n">vorinfo</span> <span class="o">=</span> <span class="n">pyvoro</span><span class="o">.</span><span class="n">create_finite_voronoi_2d</span><span class="p">(</span><span class="n">vor</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">regions</span><span class="p">)</span>
<span class="go">[[3, 2, 0, 1], [0, 4, 5], [7, 1, 0, 6], [9, 8, 1]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">vorinfo</span><span class="p">)</span>
<span class="go">[[  -15.            31.66666667]</span>
<span class="go"> [  -25.            15.        ]</span>
<span class="go"> [ 6641.4023547  -4405.93490314]</span>
<span class="go"> [ 5631.85424949 -5641.85424949]</span>
<span class="go"> [ 6641.4023547  -4405.93490314]</span>
<span class="go"> [  -15.          8031.66666667]</span>
<span class="go"> [  -15.          8031.66666667]</span>
<span class="go"> [-5681.85424949 -5641.85424949]</span>
<span class="go"> [ 5631.85424949 -5641.85424949]</span>
<span class="go"> [-5681.85424949 -5641.85424949]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="pycoverage.vorutils.pyvoro.create_transparent_cmap">
<code class="sig-prename descclassname">pycoverage.vorutils.pyvoro.</code><code class="sig-name descname">create_transparent_cmap</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cmap</span></em>, <em class="sig-param"><span class="n">N</span><span class="o">=</span><span class="default_value">255</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycoverage.vorutils.pyvoro.create_transparent_cmap" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a transparent colormap based on a matplotlib.pyplot colormap.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>cmap</strong><span class="classifier">matplotlib.pyplot.cmap instance</span></dt><dd><p>Cmap object containing information about the colormap.</p>
</dd>
<dt><strong>N</strong><span class="classifier">int, optional</span></dt><dd><p>Value used in determining alpha, which determines the opacity of the transparent colormap, by default 255. The value of N should be between 0 and 255.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>transparent_cmap</strong><span class="classifier">matplotlib.pyplot.cmap instance</span></dt><dd><p>Cmap object containing information about the transparent colormap.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Generates a transparent colormap based on the RED colormap scheme from Matplotlib.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">transparent_cmap</span> <span class="o">=</span> <span class="n">pyvoro</span><span class="o">.</span><span class="n">create_transparent_cmap</span><span class="p">(</span><span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">Reds</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="pycoverage.vorutils.pyvoro.create_triangulation">
<code class="sig-prename descclassname">pycoverage.vorutils.pyvoro.</code><code class="sig-name descname">create_triangulation</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">poly</span></em>, <em class="sig-param"><span class="n">points</span></em>, <em class="sig-param"><span class="n">scheme</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycoverage.vorutils.pyvoro.create_triangulation" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the triangulation of the convex hull using either the defualt scheme, or by choosing the centroid as the leverage point (delaunay).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>poly</strong><span class="classifier">shapely.geometry.Polygon instance</span></dt><dd><p>Polygon representing the domain to be triangulated.</p>
</dd>
<dt><strong>points</strong><span class="classifier">list</span></dt><dd><p>List of points that form the convex hull. Asssumed to be in counter-clockwise order.</p>
</dd>
<dt><strong>scheme</strong><span class="classifier">string, optional</span></dt><dd><p>String representing which scheme to use, by default None. If None, then the default scheme is used where the points that form the hull are used, and if “delaunay” then the points from the hull and the centroid of the polygon are used.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>triangulation</strong><span class="classifier">list</span></dt><dd><p>List containing the vertices that completely define the triangles that form the triangulation.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pycoverage.vorutils.pyvoro.dmultivariate_gaussian">
<code class="sig-prename descclassname">pycoverage.vorutils.pyvoro.</code><code class="sig-name descname">dmultivariate_gaussian</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">mu</span></em>, <em class="sig-param"><span class="n">sigma</span></em>, <em class="sig-param"><span class="n">time_step</span></em>, <em class="sig-param"><span class="n">scheme</span><span class="o">=</span><span class="default_value">'fd'</span></em>, <em class="sig-param"><span class="n">vectorize</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycoverage.vorutils.pyvoro.dmultivariate_gaussian" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the derivative of the multi-variate Gaussian, with respect to time, with mean mu and standard deviation sigma.</p>
<p>To prevent division by zero due to a small mass integral output, the function is multiplied by a large constant. Therefore, this is NOT a proper probability distribution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array-like</span></dt><dd><p>The point at which the function is evaluated.</p>
</dd>
<dt><strong>mu</strong><span class="classifier">array-like</span></dt><dd><p>A (dim x 2, 3) array containing the mean of the multivariate Gaussian at either 2 time steps or 3 time steps. Can pass any number of time steps, but only the first 2 or 3 columns are used.</p>
</dd>
<dt><strong>sigma</strong><span class="classifier">array-like</span></dt><dd><p>A (dim x 2, 3) array containing the standard deviation of the multivariate Gaussian at either 2 time steps or 3 time steps. Can pass any number of time steps, but only the first 2 or 3 columns are used.</p>
</dd>
<dt><strong>time_step</strong><span class="classifier">float</span></dt><dd><p>The time step used in the numerical scheme.</p>
</dd>
<dt><strong>scheme</strong><span class="classifier">string, optional</span></dt><dd><p>The numerical scheme used, by default “fd”. The options are “fd” for forward difference scheme (current value and previous value are used), and “cd” for central differencing scheme (current value, and two previous values are used).</p>
</dd>
<dt><strong>vectorize</strong><span class="classifier">bool, optional</span></dt><dd><p>Flag determining whether or not the result is vectorized using Numpy, by default False.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>func</strong><span class="classifier">array-like</span></dt><dd><p>The value of the multivariate Gaussian function at the prescribed point x. Potentially vectorized using Numpy based on the vectorized flag.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>As of version 0.2, central differencing is not supported. Most likely, central differencing will never be supported.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mi">123</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="pycoverage.vorutils.pyvoro.dweighted_center_function">
<code class="sig-prename descclassname">pycoverage.vorutils.pyvoro.</code><code class="sig-name descname">dweighted_center_function</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">mu</span></em>, <em class="sig-param"><span class="n">sigma</span></em>, <em class="sig-param"><span class="n">time_step</span></em>, <em class="sig-param"><span class="n">scheme</span><span class="o">=</span><span class="default_value">'fd'</span></em>, <em class="sig-param"><span class="n">vectorize</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycoverage.vorutils.pyvoro.dweighted_center_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value of the weighted center of mass function, with respect to the function phi.</p>
<p>To prevent division by zero due to a small mass integral output, the function is multiplied by a large constant. Therefore, this is NOT a proper probability distribution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array-like</span></dt><dd><p>The point at which the function is evaluated.</p>
</dd>
<dt><strong>mu</strong><span class="classifier">array-like</span></dt><dd><p>A (dim x 2, 3) array containing the mean of the multivariate Gaussian at either 2 time steps or 3 time steps. Can pass any number of time steps, but only the first 2 or 3 columns are used.</p>
</dd>
<dt><strong>sigma</strong><span class="classifier">array-like</span></dt><dd><p>A (dim x 2, 3) array containing the standard deviation of the multivariate Gaussian at either 2 time steps or 3 time steps. Can pass any number of time steps, but only the first 2 or 3 columns are used.</p>
</dd>
<dt><strong>time_step</strong><span class="classifier">float</span></dt><dd><p>The time step used for the numerical approximation.</p>
</dd>
<dt><strong>scheme</strong><span class="classifier">string, optional</span></dt><dd><p>The numerical scheme used, by default “fd”. The options are “fd” for forward difference scheme (current value and previous value are used), and “cd” for central differencing scheme (current value, and two previous values are used).</p>
</dd>
<dt><strong>vectorize</strong><span class="classifier">bool, optional</span></dt><dd><p>Flag determining whether or not the result is vectorized using Numpy, by default False.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>func</strong><span class="classifier">array-like</span></dt><dd><p>The value of the multivariate Gaussian function at the prescribed point x. Potentially vectorized using Numpy based on the vectorized flag.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mi">123</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="pycoverage.vorutils.pyvoro.find_meb">
<code class="sig-prename descclassname">pycoverage.vorutils.pyvoro.</code><code class="sig-name descname">find_meb</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">points</span></em>, <em class="sig-param"><span class="n">sig_dig</span><span class="o">=</span><span class="default_value">4</span></em>, <em class="sig-param"><span class="n">epsilon</span><span class="o">=</span><span class="default_value">0.01</span></em>, <em class="sig-param"><span class="n">stop_tol</span><span class="o">=</span><span class="default_value">0.01</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycoverage.vorutils.pyvoro.find_meb" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes an approximation to the minimum enclosing ball that encloses the convex polygon defined by <code class="docutils literal notranslate"><span class="pre">points</span></code>.</p>
<p>The minimum enclosing ball is computed using the Frank-Wolfe algorithm (insert reference here) and iteratively converges to the minimum enclosing ball.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>points</strong><span class="classifier">numpy.ndarray instance</span></dt><dd><p>Array containing tuples (x, y) representing coorddinates in 2-D of the points defining the convex polygon.</p>
</dd>
<dt><strong>sig_dig</strong><span class="classifier">int, optional</span></dt><dd><p>The number of siginificant digits to truncate the computational ressults, by default 4 significant digits.</p>
</dd>
<dt><strong>epsilon</strong><span class="classifier">float, optional</span></dt><dd><p>Parameter determining the acceptable error of the approximation and number of iterations, by default 1e-3.</p>
</dd>
<dt><strong>stop_tol</strong><span class="classifier">float, optional</span></dt><dd><p>Stopping tolerance used for ending iterations early.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>circle</strong><span class="classifier">numpy.ndarray instance</span></dt><dd><p>Array containing the coordinates (x, y, radius) that define the minimum enclosing ball.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Note that the smaller <code class="docutils literal notranslate"><span class="pre">epsilon</span></code> is, the more accurate the result. However, this also increases the number of iterations by a factor of two-fold, so choose this parameter wisely.</p>
<p>The parameter <code class="docutils literal notranslate"><span class="pre">stop_tol</span></code> is used to determine if the algorithm should be terminated early. If the absolute difference between the newly computed center and the previous center is smaller than <code class="docutils literal notranslate"><span class="pre">stop_tol</span></code>, then the algorithm is terminated early.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># TODO</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="pycoverage.vorutils.pyvoro.find_polygon_centroids">
<code class="sig-prename descclassname">pycoverage.vorutils.pyvoro.</code><code class="sig-name descname">find_polygon_centroids</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">poly</span></em>, <em class="sig-param"><span class="n">points</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycoverage.vorutils.pyvoro.find_polygon_centroids" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the new Voronoi points, which are taken to be the centroids of the previous Voronoi partitions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>poly</strong><span class="classifier">shapely.geometry.Polygon</span></dt><dd><p>Polygon used for determining intersection membership.</p>
</dd>
<dt><strong>points</strong><span class="classifier">list</span></dt><dd><p>List of tuples (x,y) representing the current positions of agents.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>vorinfo</strong><span class="classifier">list</span></dt><dd><p>List containing the regions of the Voronoi partition, and the vertices of the convex hull for each region in the partition.</p>
</dd>
<dt><strong>centroids</strong><span class="classifier">list</span></dt><dd><p>List of tuples (x,y) representing the new centroid positions.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">pyvoro.create_finite_voronoi_2d</span></code></dt><dd><p>subprocedure</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>It is assumed that the polygon vertices are ordered in a counter-clockwise order.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Find the regions of the Voronoi partition.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">polygon</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">Polygon</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">95</span><span class="p">,</span> <span class="mi">31</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">59</span><span class="p">,</span> <span class="o">-</span><span class="mi">81</span><span class="p">],</span> <span class="p">[</span><span class="mi">95</span><span class="p">,</span> <span class="mi">31</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">points</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">50</span><span class="p">,</span> <span class="mi">30</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vorinfo</span><span class="p">,</span> <span class="n">centroids</span> <span class="o">=</span> <span class="n">pyvoro</span><span class="o">.</span><span class="n">find_polygon_centroids</span><span class="p">(</span><span class="n">polygon</span><span class="p">,</span> <span class="n">points</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">vorinfo</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="c1"># Regions of the partition.</span>
<span class="go">[[3, 2, 0, 1], [0, 4, 5], [7, 1, 0, 6], [9, 8, 1]]   </span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">vorinfo</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="c1"># Vertices defining the convex hull of the regions.</span>
<span class="go">array([[  -15.        ,    31.66666667],</span>
<span class="go">       [  -25.        ,    15.        ],</span>
<span class="go">       [ 6641.4023547 , -4405.93490314],</span>
<span class="go">       [ 5631.85424949, -5641.85424949],</span>
<span class="go">       [ 6641.4023547 , -4405.93490314],</span>
<span class="go">       [  -15.        ,  8031.66666667],</span>
<span class="go">       [  -15.        ,  8031.66666667],</span>
<span class="go">       [-5681.85424949, -5641.85424949],</span>
<span class="go">       [ 5631.85424949, -5641.85424949],</span>
<span class="go">       [-5681.85424949, -5641.85424949]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">centroids</span><span class="p">)</span>
<span class="go">[[7.043367194231445, 1.9724402251231876], </span>
<span class="go"> [28.929774946440688, 43.64720832302304], </span>
<span class="go"> [-51.68553805648806, 27.959361526264278], </span>
<span class="go"> [-33.479077928361086, -31.697626888791707]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="pycoverage.vorutils.pyvoro.generate_points_within_polygon">
<code class="sig-prename descclassname">pycoverage.vorutils.pyvoro.</code><code class="sig-name descname">generate_points_within_polygon</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">poly</span></em>, <em class="sig-param"><span class="n">num_points</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycoverage.vorutils.pyvoro.generate_points_within_polygon" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates random tuples of the form (x,y) which lie in the interior of a polygon.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>poly</strong><span class="classifier">shapely.geometry.Polygon instance</span></dt><dd><p>Polygon used for determining membership.</p>
</dd>
<dt><strong>num_points</strong><span class="classifier">int</span></dt><dd><p>Number of points to generate.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>random_points</strong><span class="classifier">list</span></dt><dd><p>Unordered list of tuples in the form (x,y) representing the randomly sampled points, which lie within the polygon.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function has the same functionality as generate_random_points(), as min_dist=0 is enforced. Additionally, this function is much faster than generate_random_points() even with min_dist=0 as an argument since no check is performed on separation distance.</p>
<p>This function does not compute the packing number, which is needed to determine if it is possible to generate num_points points. It is up to the user to ensure this is enforced before passing arguments onto this function.</p>
<p>It is assumed that the polygon vertices are ordered in counter-clockwise order.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Generates 3 points contained within a polygon.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">polygon</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">Polygon</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">95</span><span class="p">,</span> <span class="mi">31</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">59</span><span class="p">,</span> <span class="o">-</span><span class="mi">81</span><span class="p">],</span> <span class="p">[</span><span class="mi">95</span><span class="p">,</span> <span class="mi">31</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">random_points</span> <span class="o">=</span> <span class="n">pyvoro</span><span class="o">.</span><span class="n">generate_points_within_polygon</span><span class="p">(</span><span class="n">polygon</span><span class="p">,</span> <span class="n">num_points</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="go">[[-53.10904500583265, -7.531685953052616],</span>
<span class="go"> [13.908619808266579, 58.8310992632654],</span>
<span class="go"> [49.05513248457106, 10.135106966482866]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="pycoverage.vorutils.pyvoro.generate_random_points">
<code class="sig-prename descclassname">pycoverage.vorutils.pyvoro.</code><code class="sig-name descname">generate_random_points</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">poly</span></em>, <em class="sig-param"><span class="n">num_points</span></em>, <em class="sig-param"><span class="n">min_dist</span><span class="o">=</span><span class="default_value">0.0</span></em>, <em class="sig-param"><span class="n">sig_dig</span><span class="o">=</span><span class="default_value">4</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycoverage.vorutils.pyvoro.generate_random_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates random tuples of the form (x, y) which lie in the interior of a convex hull and are separated by <code class="docutils literal notranslate"><span class="pre">min_dist</span></code> distance, using rejection sampling. It is assumed that the hull vertices are ordered in counter-clockwise order.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>poly</strong><span class="classifier">shapely.geometry.Polygon instance</span></dt><dd><p>Convex hull used for determining membership during rejection sampling.</p>
</dd>
<dt><strong>num_points</strong><span class="classifier">int</span></dt><dd><p>Number of points to be generated.</p>
</dd>
<dt><strong>min_dist</strong><span class="classifier">float, optional</span></dt><dd><p>The minimum separation distance enforced for each point, by default 0.</p>
</dd>
<dt><strong>sig_dig</strong><span class="classifier">int, optional</span></dt><dd><p>The number of significant digits to truncate the computational results, by default 4 significant digits.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>random_points</strong><span class="classifier">list</span></dt><dd><p>Unordered list of tuples of the form (x, y) representing the randomly sampled points which lie within the convex hull, and are separated by a distance of <code class="docutils literal notranslate"><span class="pre">min_dist</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function does not compute the packing number, which is needed to determine if it is possible to generate <code class="docutils literal notranslate"><span class="pre">num_points</span></code> points that are separated by a distance of <code class="docutils literal notranslate"><span class="pre">min_dist</span></code> distance. It is the responsibility of the user to ensure that the problem is feasible.</p>
<p>It is assumed that the hull vertices are ordered in counter-clockwise order.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Generates 3 points with ``min_dist`` of 1.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hull</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">Polygon</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">95</span><span class="p">,</span> <span class="mi">31</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">59</span><span class="p">,</span> <span class="o">-</span><span class="mi">81</span><span class="p">],</span> <span class="p">[</span><span class="mi">95</span><span class="p">,</span> <span class="mi">31</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">random_points</span> <span class="o">=</span> <span class="n">geoutils</span><span class="o">.</span><span class="n">generate_random_points</span><span class="p">(</span><span class="n">hull</span><span class="p">,</span> <span class="n">num_points</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">min_dist</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Fail case where the problem is not feasible. The result is an infinite runtime!</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hull</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">Polygon</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">95</span><span class="p">,</span> <span class="mi">31</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">59</span><span class="p">,</span> <span class="o">-</span><span class="mi">81</span><span class="p">],</span> <span class="p">[</span><span class="mi">95</span><span class="p">,</span> <span class="mi">31</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">random_points</span> <span class="o">=</span> <span class="n">geoutils</span><span class="o">.</span><span class="n">generate_random_points</span><span class="p">(</span><span class="n">hull</span><span class="p">,</span> <span class="n">num_points</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">min_dist</span><span class="o">=</span><span class="mf">100.</span><span class="p">)</span>
</pre></div>
</div>
<p>TODO need to fix the examples so that they work with the sig_dig option.</p>
</dd></dl>

<dl class="py function">
<dt id="pycoverage.vorutils.pyvoro.get_triangulation_points">
<code class="sig-prename descclassname">pycoverage.vorutils.pyvoro.</code><code class="sig-name descname">get_triangulation_points</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">tri</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycoverage.vorutils.pyvoro.get_triangulation_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list containing tuples of the form [x1,x2] that represent the points of the triangulation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tri</strong><span class="classifier">list</span></dt><dd><p>List containing Shapely triangulation objects, representing the triangles that make up the triangulation.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>points</strong><span class="classifier">list</span></dt><dd><p>List of tuples of the form (x1, x2, …) containing the vertices of the triangles that define the triangulation.</p>
</dd>
<dt>Finish documentation later.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pycoverage.vorutils.pyvoro.multivariate_gaussian">
<code class="sig-prename descclassname">pycoverage.vorutils.pyvoro.</code><code class="sig-name descname">multivariate_gaussian</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">mu</span></em>, <em class="sig-param"><span class="n">sigma</span></em>, <em class="sig-param"><span class="n">scaling_factor</span><span class="o">=</span><span class="default_value">10000</span></em>, <em class="sig-param"><span class="n">vectorize</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">vector</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycoverage.vorutils.pyvoro.multivariate_gaussian" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value of a multi-variate Gaussian with mean mu and standard variation sigma.</p>
<p>To prevent division by zero due to a small mass integral output, the function is multiplied by a large constant. Therefore, this is NOT a proper probability distribution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array-like</span></dt><dd><p>The point at which the function is evaluated.</p>
</dd>
<dt><strong>mu</strong><span class="classifier">array-like</span></dt><dd><p>The mean of the multivariate Gaussian.</p>
</dd>
<dt><strong>sigma</strong><span class="classifier">array-like</span></dt><dd><p>The standard deviation of the multivariate Gaussian.</p>
</dd>
<dt><strong>vectorize</strong><span class="classifier">bool, optional</span></dt><dd><p>Flag determining whether or not the result is vectorized using Numpy, by default False.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>func</strong><span class="classifier">array-like</span></dt><dd><p>The value of the multivariate Gaussian function at the prescribed point x. Potentially vectorized using Numpy based on the vectorized flag.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mi">123</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="pycoverage.vorutils.pyvoro.to_canonical_triangle">
<code class="sig-prename descclassname">pycoverage.vorutils.pyvoro.</code><code class="sig-name descname">to_canonical_triangle</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">points</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycoverage.vorutils.pyvoro.to_canonical_triangle" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>points</strong><span class="classifier">list of tuples</span></dt><dd><p>List of points representing the vertices of the triangle.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Finish documentation later.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pycoverage.vorutils.pyvoro.vectorize_lambda_function">
<code class="sig-prename descclassname">pycoverage.vorutils.pyvoro.</code><code class="sig-name descname">vectorize_lambda_function</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">args</span></em>, <em class="sig-param"><span class="n">derivative</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycoverage.vorutils.pyvoro.vectorize_lambda_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a vectorized version of the lambda function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>func</strong><span class="classifier">lambda function</span></dt><dd><p>Python lambda function that represents the function we want to vectorize.</p>
</dd>
<dt><strong>args</strong><span class="classifier">dict</span></dt><dd><p>Dictionary of arguments sent to the original lambda function.</p>
</dd>
<dt><strong>derivative</strong><span class="classifier">bool</span></dt><dd><p>Boolean flag denoting whether or not the lambda function represents a derivative term.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>func</strong><span class="classifier">lambda function</span></dt><dd><p>A vectorized (using numpy.vectorize) lambda function that can be fed into quadrature rules.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>THIS FUNCTION IS PROBABLY GOING TO BE DEPRECATED.</p></li>
<li><p>The args dict takes the following categories: func_type, time_curr, time_prev, mu, sigma, step_size. The mu_x and sigma_x can also be Python lambda functions, but time_curr and time_prev must be a float and func_type must be a string.</p></li>
<li><p>The variable func_type is used to determine which lambda function we return. The values it can take on are: “joint” and “weighted”.</p></li>
<li><p>The derivative flag is used to determine whether or not the derivative term is returned, instead of the non-derivative term.</p></li>
</ul>
<p>Finish documentation later &amp; make this function prettier…</p>
</dd></dl>

<dl class="py function">
<dt id="pycoverage.vorutils.pyvoro.warning_on_one_line">
<code class="sig-prename descclassname">pycoverage.vorutils.pyvoro.</code><code class="sig-name descname">warning_on_one_line</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">message</span></em>, <em class="sig-param"><span class="n">category</span></em>, <em class="sig-param"><span class="n">filename</span></em>, <em class="sig-param"><span class="n">lineno</span></em>, <em class="sig-param"><span class="n">file</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">line</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycoverage.vorutils.pyvoro.warning_on_one_line" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="pycoverage.vorutils.pyvoro.weighted_center_function">
<code class="sig-prename descclassname">pycoverage.vorutils.pyvoro.</code><code class="sig-name descname">weighted_center_function</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">mu</span></em>, <em class="sig-param"><span class="n">sigma</span></em>, <em class="sig-param"><span class="n">vectorize</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">vector</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pycoverage.vorutils.pyvoro.weighted_center_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value of the weighted center of mass function, weighted by phi.</p>
<p>To prevent division by zero due to small mass integral output, the function is multiplied by a large constant. Therefore, this is NOT a proper probability distribution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array-like</span></dt><dd><p>The point at which the function is evaluated.</p>
</dd>
<dt><strong>mu</strong><span class="classifier">array-like</span></dt><dd><p>The mean of the multivariate Gaussian.</p>
</dd>
<dt><strong>sigma</strong><span class="classifier">array-like</span></dt><dd><p>The standard deviation of the multivariate Gaussian.</p>
</dd>
<dt><strong>vectorize</strong><span class="classifier">bool, optional</span></dt><dd><p>Flag determining whether or not the result is vectorized using Numpy, by default False.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>func</strong><span class="classifier">array-like</span></dt><dd><p>The value of the multivariate Gaussian function at the prescribed point x. Potentially vectorized using Numpy based on the vectorized flag.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mi">123</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="module-pycoverage.vorutils">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-pycoverage.vorutils" title="Permalink to this headline">¶</a></h2>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><h3>Page Contents</h3>
<ul>
<li><a class="reference internal" href="#">pycoverage.vorutils package</a><ul>
<li><a class="reference internal" href="#submodules">Submodules</a></li>
<li><a class="reference internal" href="#module-pycoverage.vorutils.playground">pycoverage.vorutils.playground module</a></li>
<li><a class="reference internal" href="#module-pycoverage.vorutils.pyvoro">pycoverage.vorutils.pyvoro module</a></li>
<li><a class="reference internal" href="#module-pycoverage.vorutils">Module contents</a></li>
</ul>
</li>
</ul>


  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/pycoverage.vorutils.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<form action="search.html" method="get">
  <input type="text" name="q" placeholder="Search" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
<footer class="footer">
  <p class="pull-right">
    <a href="_sources/pycoverage.vorutils.rst.txt"
       rel="nofollow">Page Source</a> &nbsp;
    <a href="#">Back to Top</a></p>
  <p>
    &copy; Copyright 2020, Simon Hu.<br/>
    Created using <a href="http://www.sphinx-doc.org/en/stable/">Sphinx</a> 3.0.3. &nbsp;
  </p>
</footer>
  </body>
</html>